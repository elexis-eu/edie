"""
    ELEXIS Protocol for accessing dictionaries

    This protocol allows data to be shared with the ELEXIS platform and should be implemented by all providers of data to the ELEXIS platform. This is an OpenAPI documentation, for more details about using this specification, please refer to OpenAPI documentations: https://swagger.io/resources/articles/documenting-apis-with-swagger/  # noqa: E501

    The version of the OpenAPI document: 1.0
    Generated by: https://openapi-generator.tech
"""

import sys
import unittest
import json

from edie.model import JsonEntry, Metadata, Entry, JsonApiResponse
from metrics.base import NumberOfSensesEvaluator, PublisherEvaluator, LicenseEvaluator, MetadataQuantityEvaluator, RecencyEvaluator, ApiEvaluator, , DefinitionOfSenseEvaluator

class TestEntry(unittest.TestCase):
    """Entry unit test stubs"""

    def setUp(self):
        pass

    def tearDown(self):
        pass

    def testEntry(self):
        """Test Entry"""
        # FIXME: construct object with mandatory attributes with example values
        # model = Entry()  # noqa: E501
        pass


class TestDefinitionOfSenses(unittest.TestCase):
    def setUp(self) -> None:
        pass

    def tearDown(self) -> None:
        pass

    def test_definition_of_sense_init(self) -> None:
        evaluator = DefinitionOfSenseEvaluator()

        self.assertEqual(evaluator.senses_count, 0)
        self.assertEqual(evaluator.definition_count, 0)
        self.assertEqual(evaluator.entry_count, 0)

    def test_reset(self) -> None:
        evaluator = DefinitionOfSenseEvaluator()
        f = open("test/data/entries.json")
        entry_json = json.load(f)
        entry: JsonEntry = JsonEntry(entry_json)
        evaluator.accumulate(entry)

        evaluator.reset()

        self.assertEqual(evaluator.senses_count, 0)
        self.assertEqual(evaluator.definition_count, 0)
        self.assertEqual(evaluator.entry_count, 0)

    def test_result(self) -> None:
        evaluator = DefinitionOfSenseEvaluator()
        f = open("test/data/entries.json")
        entry_json = json.load(f)
        entry: JsonEntry = JsonEntry(entry_json)
        evaluator.accumulate(entry)

        result = evaluator.result()

        self.assertEqual(result['DefinitionPerSense'], 1.0)
        self.assertEqual(result['DefinitionPerEntry'], 1.0)



    def test_entry(self) -> None:
            f = open("test/data/entries.json")
            entry_json = json.load(f)
            entry: JsonEntry = JsonEntry(entry_json)
            evaluator = DefinitionOfSenseEvaluator()

            evaluator.accumulate(entry)

            self.assertEqual(evaluator.entry_count, 1)
            self.assertEqual(evaluator.senses_count, 1)
            self.assertEqual(evaluator.definition_count, 1)


class TestNumberOfSenses(unittest.TestCase):

    def setUp(self):
        self.numberOfSensesEvaluator: NumberOfSensesEvaluator = NumberOfSensesEvaluator()

    def tearDown(self):
        pass

    def testEntry(self):
        f = open("test/data/entries.json")
        entry_json = json.load(f)
        f.close()

        entry: JsonEntry = JsonEntry(entry_json) # TODO: should be Entry()

        evaluator = NumberOfSensesEvaluator()

        evaluator.accumulate(entry)

        self.assertEqual(evaluator.senses_count, 1)
        self.assertEqual(evaluator.entry_count, 1)

class TestMetadata(unittest.TestCase):
    def setUp(self):
        self.publisherEvaluator: PublisherEvaluator = PublisherEvaluator()
        self.licenseEvaluator: LicenseEvaluator = LicenseEvaluator()
        self.metadataEvaluator: MetadataQuantityEvaluator = MetadataQuantityEvaluator()

    def tearDown(self):
        pass

    def testEntry(self):
        f = open("test/data/sample.json")
        entry_json = json.load(f)
        f.close()

        metadata_entry: Metadata = Metadata(entry_json)


        evaluator = PublisherEvaluator()
        evaluator.analyze(metadata_entry)
        self.assertTrue(evaluator.publisher_info_present, 'Publisher info missing')

        evaluator = LicenseEvaluator()
        evaluator.analyze(metadata_entry)
        self.assertTrue(evaluator.license_info_present, 'License info missing')

        evaluator = RecencyEvaluator()
        evaluator.analyze(metadata_entry)
        self.assertIsNotNone(evaluator.recency, 'Cannot estimate recency')
        self.assertLessEqual(evaluator.recency, 50, 'Dictionary is older than 50 years')

        evaluator = MetadataQuantityEvaluator()
        evaluator.analyze(metadata_entry)
        print(str(evaluator.metric_count) +'/'+str(evaluator.total_metrics))
        # TODO - what is the expected ratio?
        self.assertGreaterEqual(evaluator.metric_count, evaluator.total_metrics/10, 'Less than 10% of metadata')

class TestMetadataApi(unittest.TestCase):
    def setUp(self):
        self.apiEvaluator : ApiEvaluator = ApiEvaluator()

    def tearDown(self):
        pass

    def testEntry(self):
        f = open("test/data/lexonomy.json")
        entry_json = json.load(f)
        f.close()

        api_entry: JsonApiResponse = JsonApiResponse(entry_json)
        evaluator = ApiEvaluator()

        evaluator.analyze(api_entry)

        print('dictionary count ', evaluator.dict_count)
        print('languages count ', len(evaluator.languages))
        for lan in evaluator.languages:
            print(lan, evaluator.languages[lan])

        self.assertGreaterEqual(evaluator.dict_count,1)

        #self.assertEqual(evaluator.senses_count, 1)
        #self.assertEqual(evaluator.entry_count, 1)




if __name__ == '__main__':
    unittest.main()
